<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="color-scheme" content="dark light" />
  <title>Коллекция Текстур от Нейросетей</title>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    :root {
      --bg: #070b12;
      --bg-e1: #0f1723;
      --bg-e2: #142235;
      --surface: #17283d;
      --text: #e8edf7;
      --muted: #9eb2cc;
      --accent: #39d0ff;
      --accent2: #00b17a;
      --danger: #f35b6f;
      --border: rgba(130, 170, 215, 0.25);
      --shadow: 0 14px 36px rgba(0, 0, 0, 0.45);
      --radius: 16px;
      --focus: 0 0 0 3px rgba(57, 208, 255, 0.35);
    }

    [data-theme="light"] {
      --bg: #eef4fb;
      --bg-e1: #fdfefe;
      --bg-e2: #eef5ff;
      --surface: #fff;
      --text: #10233f;
      --muted: #4d6485;
      --accent: #0f8fc4;
      --accent2: #0f9f70;
      --danger: #d53f52;
      --border: rgba(36, 84, 130, 0.2);
      --shadow: 0 16px 28px rgba(16, 45, 81, 0.12);
      --focus: 0 0 0 3px rgba(15, 143, 196, 0.28);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      background: var(--bg);
      font-family: Manrope, "Segoe UI", sans-serif;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background:
        radial-gradient(circle at 20% 20%, rgba(57, 208, 255, 0.28), transparent 45%),
        radial-gradient(circle at 82% 8%, rgba(0, 177, 122, 0.25), transparent 35%),
        linear-gradient(150deg, #06101e, #0c1524 40%, #0b121d);
    }

    .container { width: min(1240px, 94vw); margin: 0 auto; padding: 24px 0 48px; }

    .hero {
      position: sticky;
      top: 12px;
      z-index: 10;
      border: 1px solid var(--border);
      border-radius: 22px;
      padding: 24px;
      background: linear-gradient(145deg, var(--bg-e1), var(--bg-e2));
      box-shadow: var(--shadow);
    }

    .hero-top { display: flex; gap: 12px; justify-content: space-between; flex-wrap: wrap; }
    h1 { margin: 0 0 8px; font-size: clamp(1.55rem, 2.4vw, 2.3rem); }
    .subtitle { margin: 0; color: var(--muted); }

    .row { margin-top: 12px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    .btn,
    .chip,
    .icon,
    .small,
    .modal-btn,
    .page {
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      cursor: pointer;
      transition: transform .2s ease, border-color .2s ease;
    }

    .btn,
    .chip { border-radius: 999px; padding: 10px 16px; }

    .btn:hover,
    .chip:hover,
    .icon:hover,
    .small:hover,
    .modal-btn:hover,
    .page:hover { transform: translateY(-1px); }

    .btn:focus-visible,
    .chip:focus-visible,
    .icon:focus-visible,
    .search:focus-visible,
    .small:focus-visible,
    .modal-btn:focus-visible,
    .page:focus-visible {
      outline: none;
      box-shadow: var(--focus);
    }

    .btn.primary {
      font-weight: 700;
      background: linear-gradient(145deg, color-mix(in srgb, var(--accent) 20%, var(--surface)), color-mix(in srgb, var(--accent) 35%, #001720));
      border-color: color-mix(in srgb, var(--accent) 65%, var(--border));
    }

    .btn.secondary {
      border-style: dashed;
      color: var(--muted);
    }

    .icon { border-radius: 12px; padding: 10px 12px; min-width: 42px; font-weight: 700; }

    .search {
      flex: 1;
      min-width: 240px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--surface) 88%, transparent);
      color: var(--text);
      padding: 11px 14px;
    }

    .cats { display: flex; flex-wrap: wrap; gap: 8px; }
    .chip.active {
      background: color-mix(in srgb, var(--accent) 30%, var(--surface));
      border-color: color-mix(in srgb, var(--accent) 75%, var(--border));
      font-weight: 700;
    }

    .status { margin-top: 10px; display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap; color: var(--muted); font-size: .88rem; }

    .progress { margin-top: 8px; height: 8px; border-radius: 999px; border: 1px solid var(--border); overflow: hidden; display: none; }
    .progress[data-show="1"] { display: block; }
    .bar { width: 0; height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); }

    .hint {
      margin-top: 10px;
      border: 1px dashed var(--border);
      border-radius: 12px;
      color: var(--muted);
      padding: 10px 12px;
      font-size: .86rem;
    }

    .grid { margin-top: 18px; display: grid; grid-template-columns: repeat(auto-fill, minmax(230px, 1fr)); gap: 14px; }

    .card {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: linear-gradient(155deg, color-mix(in srgb, var(--surface) 96%, transparent), color-mix(in srgb, var(--surface) 80%, black));
      box-shadow: var(--shadow);
      min-height: 320px;
      display: flex;
      flex-direction: column;
      transform: translateY(10px);
      opacity: 0;
      animation: cardIn .35s ease forwards;
    }

    @keyframes cardIn { to { opacity: 1; transform: none; } }

    .preview-wrap { position: relative; aspect-ratio: 1 / 1; background: linear-gradient(165deg, #0f2238, #0d1622); }
    .preview { width: 100%; height: 100%; object-fit: cover; transition: transform .3s ease; }
    .card:hover .preview { transform: scale(1.05); }
    .placeholder { position: absolute; inset: 0; display: grid; place-items: center; color: var(--muted); font-size: .87rem; }

    .card-body { padding: 12px; display: flex; flex-direction: column; gap: 8px; flex: 1; }
    .badge { display: inline-flex; width: fit-content; border: 1px solid var(--border); border-radius: 999px; padding: 4px 9px; font-size: .75rem; color: var(--muted); }
    .title { margin: 0; font-size: 1rem; word-break: break-word; }
    .meta { margin: 0; color: var(--muted); font-size: .82rem; min-height: 38px; }

    .actions { margin-top: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .small { border-radius: 10px; padding: 8px; font-size: .85rem; }
    .small.zip {
      background: color-mix(in srgb, var(--accent2) 23%, var(--surface));
      border-color: color-mix(in srgb, var(--accent2) 60%, var(--border));
    }

    .empty {
      margin-top: 18px;
      border: 1px dashed var(--border);
      border-radius: var(--radius);
      background: color-mix(in srgb, var(--surface) 65%, transparent);
      color: var(--muted);
      padding: 20px;
      text-align: center;
      display: none;
    }

    .empty[data-show="1"] { display: block; }

    .pager { margin-top: 14px; display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; }
    .page { border-radius: 10px; min-width: 38px; height: 38px; padding: 0 12px; }
    .page.active {
      font-weight: 700;
      background: color-mix(in srgb, var(--accent) 28%, var(--surface));
      border-color: color-mix(in srgb, var(--accent) 65%, var(--border));
    }
    .page:disabled { opacity: .45; cursor: not-allowed; }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(3, 10, 16, .86);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 40;
    }

    .modal[data-open="1"] { display: flex; }

    .modal-content {
      width: min(1120px, 100%);
      max-height: calc(100vh - 28px);
      border: 1px solid var(--border);
      border-radius: 18px;
      background: linear-gradient(155deg, var(--bg-e1), var(--bg-e2));
      box-shadow: var(--shadow);
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    .modal-head,
    .modal-foot {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .modal-foot {
      border-bottom: 0;
      border-top: 1px solid var(--border);
    }

    .modal-stage {
      min-height: 360px;
      display: grid;
      grid-template-columns: 76px 1fr;
    }

    .thumbs {
      border-right: 1px solid var(--border);
      overflow: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .thumb {
      width: 58px;
      height: 58px;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: var(--surface);
      padding: 0;
      cursor: pointer;
    }

    .thumb.active { border-color: color-mix(in srgb, var(--accent) 70%, var(--border)); }
    .thumb img { width: 100%; height: 100%; object-fit: cover; }

    .viewer {
      position: relative;
      overflow: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      background: color-mix(in srgb, var(--surface) 65%, black);
    }

    .viewer img { max-width: 100%; max-height: 68vh; transition: transform .2s ease; }

    .seamless {
      width: min(920px, 94%);
      height: min(68vh, 620px);
      border: 1px solid var(--border);
      border-radius: 12px;
      display: none;
      background-repeat: repeat;
      background-position: center;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }

    .seamless[data-on="1"] { display: block; }

    .modal-btn { border-radius: 10px; padding: 8px 11px; }
    .modal-btn.active {
      background: color-mix(in srgb, var(--accent) 30%, var(--surface));
      border-color: color-mix(in srgb, var(--accent) 75%, var(--border));
    }

    .label { color: var(--muted); font-size: .84rem; border: 1px solid var(--border); border-radius: 999px; padding: 6px 10px; }
    .sr { position: absolute; width: 1px; height: 1px; margin: -1px; clip: rect(0 0 0 0); overflow: hidden; }

    @media (max-width: 860px) {
      .hero { position: static; }
      .modal-stage { grid-template-columns: 1fr; }
      .thumbs { flex-direction: row; border-right: 0; border-bottom: 1px solid var(--border); }
      .viewer img { max-height: 56vh; }
      .seamless { height: min(56vh, 440px); }
    }

    @media (max-width: 620px) {
      .container { width: min(1240px, 96vw); padding-top: 12px; }
      .hero { padding: 16px; }
      .actions { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="container">
    <section class="hero" aria-label="Панель управления">
      <div class="hero-top">
        <div>
          <h1 id="title">Коллекция Текстур от Нейросетей</h1>
          <p class="subtitle" id="subtitle">Просмотр, категоризация и скачивание твоих AI-генерированных текстур</p>
        </div>
        <div class="row">
          <button id="themeBtn" class="icon" type="button" aria-label="Переключить тему">☼</button>
          <button id="langBtn" class="icon" type="button" aria-label="Switch language">EN</button>
        </div>
      </div>

      <div class="row">
        <button id="loadServerBtn" class="btn primary" type="button">Загрузить каталог сайта</button>
        <label for="folderInput" class="btn secondary" id="localBtn">Импорт с компьютера (опционально)</label>
        <input id="folderInput" class="sr" type="file" webkitdirectory directory multiple />
      </div>

      <div class="hint" id="deployHint">Для домена используй серверный каталог: создай файл <code>textures/index.json</code> и храни изображения в <code>/textures/...</code>. Локальная папка нужна только для быстрого импорта.</div>

      <div class="row">
        <label for="searchInput" class="sr" id="searchLabel">Поиск</label>
        <input id="searchInput" class="search" type="search" placeholder="Поиск: oak, wood, metal..." />
      </div>

      <div id="categories" class="cats" role="tablist"></div>

      <div class="status"><span id="statusText">Нажмите «Загрузить каталог сайта» или импортируйте папку.</span><span id="countText">0 текстур</span></div>
      <div class="progress" id="progress" data-show="0"><div class="bar" id="bar"></div></div>
    </section>

    <section id="grid" class="grid"></section>
    <section id="empty" class="empty"></section>
    <nav id="pager" class="pager"></nav>
  </main>

  <div id="modal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-head">
        <h2 id="modalTitle" style="margin:0;font-size:1rem">Текстура</h2>
        <button id="closeModal" class="modal-btn" type="button">Закрыть</button>
      </div>

      <div class="modal-stage">
        <div id="thumbs" class="thumbs"></div>
        <div id="viewer" class="viewer">
          <img id="modalImage" alt="Просмотр карты" />
          <div id="seamless" class="seamless" data-on="0" aria-label="Проверка бесшовности"></div>
        </div>
      </div>

      <div class="modal-foot">
        <div class="row" style="margin-top:0;">
          <span id="mapLabel" class="label">Map</span>
          <button id="prevBtn" class="modal-btn" type="button">◀</button>
          <button id="nextBtn" class="modal-btn" type="button">▶</button>
          <button id="seamBtn" class="modal-btn" type="button">Бесшовность</button>
          <button id="zoomOut" class="modal-btn" type="button">−</button>
          <button id="zoomIn" class="modal-btn" type="button">＋</button>
          <button id="zoomReset" class="modal-btn" type="button">100%</button>
        </div>
        <span id="modalHint" style="color:var(--muted);font-size:.78rem;">В обычном режиме зумит изображение. В режиме «Бесшовность» меняет размер тайла.</span>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const PAGE_SIZE = 50;
      const SERVER_MANIFEST = "textures/index.json";
      const SUPPORTED_EXT = ["jpg", "jpeg", "png", "webp", "tif", "tiff"];
      const TYPE_ALIASES = {
        basecolor: ["basecolor", "albedo", "diffuse", "color", "col"],
        normal: ["normal", "nrm", "nor"],
        roughness: ["roughness", "rough"],
        metalness: ["metalness", "metallic", "metal"],
        ao: ["ao", "ambientocclusion", "occlusion"],
        displacement: ["displacement", "height", "disp"],
      };

      const i18n = {
        ru: {
          title: "Коллекция Текстур от Нейросетей",
          subtitle: "Просмотр, категоризация и скачивание твоих AI-генерированных текстур",
          loadServer: "Загрузить каталог сайта",
          localImport: "Импорт с компьютера (опционально)",
          deployHint: "Для домена используй серверный каталог: создай файл textures/index.json и храни изображения в /textures/... Локальная папка нужна только для быстрого импорта.",
          search: "Поиск: oak, wood, metal...",
          idle: "Нажмите «Загрузить каталог сайта» или импортируйте папку.",
          scanning: "Сканирование файлов...",
          loadingServer: "Загрузка каталога с сервера...",
          ready: "Готово: найдено текстур",
          noImages: "Изображения не найдены.",
          manifestMissing: "Не удалось загрузить textures/index.json. Добавьте манифест на сервер или используйте локальный импорт.",
          all: "Все",
          unc: "Без категории",
          view: "Просмотр",
          zip: "Скачать архив",
          empty: "Нет текстур для текущего фильтра.",
          textures: "текстур",
          map: "Карта",
          close: "Закрыть",
          seamless: "Бесшовность",
          zipStart: "Создаю ZIP...",
          zipDone: "ZIP скачан:",
          zipErr: "Не удалось создать ZIP.",
        },
        en: {
          title: "AI Texture Collection",
          subtitle: "Browse, categorize, and download your AI-generated textures",
          loadServer: "Load site catalog",
          localImport: "Import from computer (optional)",
          deployHint: "For domain deploy, use server catalog: create textures/index.json and store images in /textures/... Local folder import is optional.",
          search: "Search: oak, wood, metal...",
          idle: "Click \"Load site catalog\" or import local folder.",
          scanning: "Scanning files...",
          loadingServer: "Loading server catalog...",
          ready: "Done: textures found",
          noImages: "No images found.",
          manifestMissing: "Cannot load textures/index.json. Add manifest to server or use local import.",
          all: "All",
          unc: "Uncategorized",
          view: "View",
          zip: "Download ZIP",
          empty: "No textures match current filter.",
          textures: "textures",
          map: "Map",
          close: "Close",
          seamless: "Seamless",
          zipStart: "Creating ZIP...",
          zipDone: "ZIP saved:",
          zipErr: "Failed to create ZIP.",
        },
      };

      const state = {
        items: [],
        filtered: [],
        categories: [],
        category: "all",
        query: "",
        page: 1,
        lang: localStorage.getItem("texture-lang") || "ru",
        theme: localStorage.getItem("texture-theme") || "dark",
        modal: { open: false, index: -1, file: 0, zoom: 1, seamless: false },
      };

      const el = {
        title: document.getElementById("title"),
        subtitle: document.getElementById("subtitle"),
        themeBtn: document.getElementById("themeBtn"),
        langBtn: document.getElementById("langBtn"),
        loadServerBtn: document.getElementById("loadServerBtn"),
        localBtn: document.getElementById("localBtn"),
        deployHint: document.getElementById("deployHint"),
        folderInput: document.getElementById("folderInput"),
        searchInput: document.getElementById("searchInput"),
        searchLabel: document.getElementById("searchLabel"),
        categories: document.getElementById("categories"),
        statusText: document.getElementById("statusText"),
        countText: document.getElementById("countText"),
        progress: document.getElementById("progress"),
        bar: document.getElementById("bar"),
        grid: document.getElementById("grid"),
        empty: document.getElementById("empty"),
        pager: document.getElementById("pager"),
        modal: document.getElementById("modal"),
        modalTitle: document.getElementById("modalTitle"),
        closeModal: document.getElementById("closeModal"),
        thumbs: document.getElementById("thumbs"),
        viewer: document.getElementById("viewer"),
        modalImage: document.getElementById("modalImage"),
        seamless: document.getElementById("seamless"),
        mapLabel: document.getElementById("mapLabel"),
        prevBtn: document.getElementById("prevBtn"),
        nextBtn: document.getElementById("nextBtn"),
        seamBtn: document.getElementById("seamBtn"),
        zoomOut: document.getElementById("zoomOut"),
        zoomIn: document.getElementById("zoomIn"),
        zoomReset: document.getElementById("zoomReset"),
        modalHint: document.getElementById("modalHint"),
      };
      const t = k => i18n[state.lang][k] || k;
      const norm = v => String(v || "").trim().toLowerCase();
      const debounce = (fn, ms = 220) => { let tm; return (...a) => { clearTimeout(tm); tm = setTimeout(() => fn(...a), ms); }; };

      function setStatus(text) { el.statusText.textContent = text; }
      function setCount(n) { el.countText.textContent = `${n} ${t("textures")}`; }
      function setProgress(p, show = true) { el.progress.dataset.show = show ? "1" : "0"; el.bar.style.width = `${Math.max(0, Math.min(100, p))}%`; }

      function applyTheme() {
        document.documentElement.setAttribute("data-theme", state.theme);
        localStorage.setItem("texture-theme", state.theme);
        el.themeBtn.textContent = state.theme === "dark" ? "☼" : "☾";
      }

      function applyLang() {
        const L = i18n[state.lang];
        document.documentElement.lang = state.lang;
        document.title = L.title;
        el.title.textContent = L.title;
        el.subtitle.textContent = L.subtitle;
        el.loadServerBtn.textContent = L.loadServer;
        el.localBtn.textContent = L.localImport;
        el.deployHint.textContent = L.deployHint;
        el.searchInput.placeholder = L.search;
        el.searchLabel.textContent = L.search;
        el.closeModal.textContent = L.close;
        el.seamBtn.textContent = L.seamless;
        el.langBtn.textContent = state.lang === "ru" ? "EN" : "RU";
        el.empty.textContent = L.empty;
        if (!state.items.length) { setStatus(L.idle); setCount(0); }
        localStorage.setItem("texture-lang", state.lang);
      }

      function mapType(name) {
        const stem = norm(name.replace(/\.[^.]+$/, ""));
        const chunks = stem.split(/[_\-\s.]+/g);
        for (const [key, arr] of Object.entries(TYPE_ALIASES)) if (arr.some(a => chunks.includes(a))) return key;
        return chunks[chunks.length - 1] || "map";
      }

      function primaryScore(name) {
        const s = norm(name);
        let p = 0;
        if (s.includes("basecolor") || s.includes("albedo") || s.includes("diffuse")) p += 12;
        if (s.includes("preview") || s.includes("thumb")) p += 8;
        if (s.includes("normal")) p -= 2;
        return p;
      }

      function pickPreview(files) {
        if (!files.length) return null;
        return [...files].sort((a, b) => primaryScore(b.name) - primaryScore(a.name) || a.name.localeCompare(b.name))[0];
      }

      async function createPreviewUrl(src, fileObj = null) {
        try {
          const img = await new Promise((resolve, reject) => {
            const i = new Image();
            i.onload = () => resolve(i);
            i.onerror = reject;
            i.src = src;
          });
          const c = document.createElement("canvas");
          c.width = 300; c.height = 300;
          const x = c.getContext("2d");
          const k = Math.max(300 / img.width, 300 / img.height);
          const w = img.width * k, h = img.height * k;
          x.drawImage(img, (300 - w) / 2, (300 - h) / 2, w, h);
          const b = await new Promise(ok => c.toBlob(ok, "image/webp", 0.88));
          return b ? URL.createObjectURL(b) : src;
        } catch {
          if (fileObj) return URL.createObjectURL(fileObj);
          return src;
        }
      }

      function parseLocalPath(file) {
        const rel = file.webkitRelativePath || file.name;
        const parts = rel.split("/").filter(Boolean);
        const filename = parts[parts.length - 1] || file.name;
        const base = filename.replace(/\.[^.]+$/, "");
        let category = t("unc");
        let tex = "";
        if (parts.length >= 4) { category = parts[1] || t("unc"); tex = parts[2] || ""; }
        else if (parts.length === 3) { category = parts[1] || t("unc"); }
        else if (parts.length === 2) { category = parts[0] || t("unc"); }
        if (!tex) tex = (base.split("_")[0] || base);
        return { category, name: tex, filename, rel };
      }

      async function loadFromLocal(list) {
        if (!list?.length) return;
        setStatus(t("scanning"));
        setProgress(2, true);
        const valid = [...list].filter(f => f.type.startsWith("image/") || SUPPORTED_EXT.includes(norm(f.name.split(".").pop())));
        if (!valid.length) { state.items = []; filterItems(); setStatus(t("noImages")); setProgress(0, false); return; }

        const grouped = new Map();
        let done = 0;
        for (const file of valid) {
          const p = parseLocalPath(file);
          const key = `${norm(p.category)}::${norm(p.name)}`;
          const obj = grouped.get(key) || { name: p.name, category: p.category, files: [] };
          obj.files.push({ name: file.name, type: mapType(file.name), src: URL.createObjectURL(file), file, preview: "" });
          grouped.set(key, obj);
          done += 1;
          if (done % 10 === 0 || done === valid.length) setProgress(Math.round(done / valid.length * 84), true);
        }

        const textures = [...grouped.values()].sort((a, b) => a.name.localeCompare(b.name));
        await Promise.all(textures.map(async (tx, i) => {
          const p = pickPreview(tx.files) || tx.files[0];
          tx.preview = p ? await createPreviewUrl(p.src, p.file) : "";
          setProgress(85 + Math.round((i + 1) / textures.length * 15), true);
        }));

        state.items = textures;
        state.category = "all";
        state.page = 1;
        updateCategories();
        filterItems();
        setStatus(`${t("ready")}: ${state.items.length}`);
        setTimeout(() => setProgress(0, false), 260);
      }

      async function loadFromServer() {
        setStatus(t("loadingServer"));
        setProgress(10, true);
        try {
          const r = await fetch(SERVER_MANIFEST, { cache: "no-store" });
          if (!r.ok) throw new Error(String(r.status));
          const data = await r.json();
          const list = Array.isArray(data) ? data : (Array.isArray(data.textures) ? data.textures : []);
          if (!list.length) throw new Error("empty");

          const textures = [];
          let n = 0;
          for (const tItem of list) {
            const files = Array.isArray(tItem.files) ? tItem.files : [];
            const mapped = files.map(f => ({
              name: f.name || (String(f.url || "").split("/").pop() || "map"),
              type: f.type || mapType(f.name || f.url || "map"),
              src: f.url,
              file: null,
              preview: "",
            })).filter(f => f.src);

            if (!mapped.length) continue;
            const tx = {
              name: tItem.name || (mapped[0].name.split("_")[0] || "texture"),
              category: tItem.category || t("unc"),
              files: mapped,
              preview: "",
            };
            textures.push(tx);
            n += 1;
            setProgress(Math.min(85, 10 + Math.round(n / list.length * 70)), true);
          }

          await Promise.all(textures.map(async (tx, i) => {
            const p = pickPreview(tx.files) || tx.files[0];
            tx.preview = p ? await createPreviewUrl(p.src) : "";
            setProgress(86 + Math.round((i + 1) / textures.length * 14), true);
          }));

          state.items = textures;
          state.category = "all";
          state.page = 1;
          updateCategories();
          filterItems();
          setStatus(`${t("ready")}: ${state.items.length}`);
        } catch {
          setStatus(t("manifestMissing"));
        } finally {
          setTimeout(() => setProgress(0, false), 260);
        }
      }

      function updateCategories() {
        const map = new Map();
        for (const tx of state.items) map.set(norm(tx.category) || "unc", tx.category || t("unc"));
        state.categories = [{ key: "all", label: t("all") }, ...[...map.entries()].map(([key, label]) => ({ key, label }))];
      }

      function filterItems() {
        const q = norm(state.query);
        state.filtered = state.items.filter(tx => {
          if (state.category !== "all" && norm(tx.category) !== state.category) return false;
          if (!q) return true;
          const hay = `${tx.name} ${tx.category} ${tx.files.map(f => f.type).join(" ")}`.toLowerCase();
          return hay.includes(q);
        });
        const maxPage = Math.max(1, Math.ceil(state.filtered.length / PAGE_SIZE));
        state.page = Math.min(state.page, maxPage);
        render();
      }

      function pageItems() {
        const start = (state.page - 1) * PAGE_SIZE;
        return state.filtered.slice(start, start + PAGE_SIZE);
      }

      function summary(files) {
        const u = [...new Set(files.map(f => f.type))].slice(0, 4);
        return `${files.length} maps: ${u.join(", ")}${files.length > u.length ? ", ..." : ""}`;
      }
      function createCard(tx, absIndex) {
        const a = document.createElement("article");
        a.className = "card";
        const p = pickPreview(tx.files) || tx.files[0] || null;
        const src = tx.preview || p?.src || "";
        a.innerHTML = `
          <div class="preview-wrap">${src ? `<img class="preview" src="${src}" alt="${tx.name}" loading="lazy" decoding="async" />` : `<div class="placeholder">no preview</div>`}</div>
          <div class="card-body">
            <span class="badge">${tx.category || t("unc")}</span>
            <h3 class="title">${tx.name}</h3>
            <p class="meta">${summary(tx.files)}</p>
            <div class="actions">
              <button class="small" type="button" data-action="view" data-index="${absIndex}">${t("view")}</button>
              <button class="small zip" type="button" data-action="zip" data-index="${absIndex}">${t("zip")}</button>
            </div>
          </div>
        `;
        return a;
      }

      function renderCategories() {
        el.categories.innerHTML = "";
        for (const c of state.categories) {
          const b = document.createElement("button");
          b.type = "button";
          b.className = `chip${state.category === c.key ? " active" : ""}`;
          b.textContent = c.label;
          b.dataset.key = c.key;
          b.setAttribute("role", "tab");
          b.setAttribute("aria-selected", state.category === c.key ? "true" : "false");
          el.categories.appendChild(b);
        }
      }

      function renderGrid() {
        el.grid.innerHTML = "";
        if (!state.filtered.length) {
          el.empty.dataset.show = "1";
          el.empty.textContent = t("empty");
          return;
        }
        el.empty.dataset.show = "0";
        const start = (state.page - 1) * PAGE_SIZE;
        pageItems().forEach((tx, i) => el.grid.appendChild(createCard(tx, start + i)));
      }

      function renderPager() {
        const total = Math.max(1, Math.ceil(state.filtered.length / PAGE_SIZE));
        el.pager.innerHTML = "";
        const mk = (label, p, dis = false, active = false) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = `page${active ? " active" : ""}`;
          b.textContent = label;
          b.disabled = dis;
          b.dataset.page = String(p);
          return b;
        };

        el.pager.appendChild(mk("◀", Math.max(1, state.page - 1), state.page <= 1));
        const set = new Set([1, total]);
        for (let i = state.page - 2; i <= state.page + 2; i += 1) if (i > 1 && i < total) set.add(i);
        [...set].sort((a, b) => a - b).forEach(p => el.pager.appendChild(mk(String(p), p, false, p === state.page)));
        el.pager.appendChild(mk("▶", Math.min(total, state.page + 1), state.page >= total));
      }

      function render() {
        renderCategories();
        renderGrid();
        renderPager();
        setCount(state.filtered.length || state.items.length || 0);
      }

      async function downloadZip(item) {
        if (typeof JSZip === "undefined" || typeof saveAs === "undefined") {
          setStatus(t("zipErr"));
          return;
        }
        setStatus(`${t("zipStart")} ${item.name}`);
        const z = new JSZip();
        const folderName = String(item.name || "texture").replace(/[\\/:*?"<>|]+/g, "_").trim() || "texture";
        const folder = z.folder(folderName);

        for (const f of item.files) {
          if (f.file) {
            folder.file(f.name, f.file);
          } else {
            const r = await fetch(f.src);
            const b = await r.blob();
            folder.file(f.name, b);
          }
        }

        const blob = await z.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }, m => setProgress(Math.round(m.percent), true));
        saveAs(blob, `${folderName}.zip`);
        setProgress(0, false);
        setStatus(`${t("zipDone")} ${folderName}.zip`);
      }

      function updateViewerScale() {
        const seamless = state.modal.seamless;
        if (!seamless) {
          el.modalImage.style.display = "block";
          el.seamless.dataset.on = "0";
          el.modalImage.style.transform = `scale(${state.modal.zoom})`;
          return;
        }

        el.modalImage.style.display = "none";
        el.seamless.dataset.on = "1";
        const tile = Math.max(16, Math.min(1024, Math.round(256 * state.modal.zoom)));
        el.seamless.style.backgroundSize = `${tile}px ${tile}px`;
      }

      function openModal(index, fileIndex = 0) {
        const tx = state.filtered[index];
        if (!tx) return;
        state.modal.open = true;
        state.modal.index = index;
        state.modal.file = Math.max(0, Math.min(fileIndex, tx.files.length - 1));
        state.modal.zoom = 1;
        state.modal.seamless = false;
        el.modal.dataset.open = "1";
        el.modal.setAttribute("aria-hidden", "false");
        document.body.style.overflow = "hidden";
        renderModal();
      }

      function closeModal() {
        state.modal.open = false;
        el.modal.dataset.open = "0";
        el.modal.setAttribute("aria-hidden", "true");
        document.body.style.overflow = "";
      }

      function renderModal() {
        if (!state.modal.open) return;
        const tx = state.filtered[state.modal.index];
        if (!tx) return;
        const f = tx.files[state.modal.file] || tx.files[0];
        if (!f) return;

        el.modalTitle.textContent = `${tx.name} • ${tx.category}`;
        el.modalImage.src = f.src;
        el.modalImage.alt = `${tx.name} ${f.type}`;
        el.mapLabel.textContent = `${t("map")}: ${f.type} (${state.modal.file + 1}/${tx.files.length})`;
        el.seamless.style.backgroundImage = `url("${f.src}")`;
        el.seamBtn.classList.toggle("active", state.modal.seamless);

        el.thumbs.innerHTML = "";
        tx.files.forEach((file, i) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = `thumb${i === state.modal.file ? " active" : ""}`;
          b.dataset.index = String(i);
          b.innerHTML = `<img src="${file.src}" alt="${file.type}" loading="lazy" />`;
          el.thumbs.appendChild(b);
        });

        updateViewerScale();
      }

      function modalStep(delta) {
        const tx = state.filtered[state.modal.index];
        if (!tx) return;
        const len = tx.files.length;
        state.modal.file = (state.modal.file + delta + len) % len;
        state.modal.zoom = 1;
        renderModal();
      }

      function setZoom(v) {
        state.modal.zoom = Math.max(0.2, Math.min(6, v));
        updateViewerScale();
      }

      function bindEvents() {
        el.themeBtn.addEventListener("click", () => { state.theme = state.theme === "dark" ? "light" : "dark"; applyTheme(); });
        el.langBtn.addEventListener("click", () => { state.lang = state.lang === "ru" ? "en" : "ru"; applyLang(); updateCategories(); render(); });
        el.loadServerBtn.addEventListener("click", loadFromServer);
        el.folderInput.addEventListener("change", async e => loadFromLocal(e.target.files));
        el.searchInput.addEventListener("input", debounce(e => { state.query = e.target.value; state.page = 1; filterItems(); }));

        el.categories.addEventListener("click", e => {
          const b = e.target.closest("button[data-key]");
          if (!b) return;
          state.category = b.dataset.key;
          state.page = 1;
          filterItems();
        });

        el.pager.addEventListener("click", e => {
          const b = e.target.closest("button[data-page]");
          if (!b || b.disabled) return;
          state.page = Number(b.dataset.page) || 1;
          render();
        });

        el.grid.addEventListener("click", async e => {
          const b = e.target.closest("button[data-action]");
          if (!b) return;
          const i = Number(b.dataset.index);
          const item = state.filtered[i];
          if (!item) return;
          if (b.dataset.action === "view") openModal(i);
          if (b.dataset.action === "zip") {
            try { await downloadZip(item); } catch { setStatus(t("zipErr")); setProgress(0, false); }
          }
        });

        el.closeModal.addEventListener("click", closeModal);
        el.prevBtn.addEventListener("click", () => modalStep(-1));
        el.nextBtn.addEventListener("click", () => modalStep(1));
        el.seamBtn.addEventListener("click", () => { state.modal.seamless = !state.modal.seamless; updateViewerScale(); el.seamBtn.classList.toggle("active", state.modal.seamless); });
        el.zoomIn.addEventListener("click", () => setZoom(state.modal.zoom + 0.2));
        el.zoomOut.addEventListener("click", () => setZoom(state.modal.zoom - 0.2));
        el.zoomReset.addEventListener("click", () => setZoom(1));

        el.thumbs.addEventListener("click", e => {
          const b = e.target.closest("button[data-index]");
          if (!b) return;
          state.modal.file = Number(b.dataset.index) || 0;
          state.modal.zoom = 1;
          renderModal();
        });

        el.viewer.addEventListener("wheel", e => {
          if (!state.modal.open) return;
          e.preventDefault();
          setZoom(state.modal.zoom + (e.deltaY > 0 ? -0.08 : 0.08));
        }, { passive: false });

        el.modal.addEventListener("click", e => { if (e.target === el.modal) closeModal(); });

        window.addEventListener("keydown", e => {
          if (!state.modal.open) return;
          if (e.key === "Escape") closeModal();
          if (e.key === "ArrowRight") modalStep(1);
          if (e.key === "ArrowLeft") modalStep(-1);
          if (e.key === "+" || e.key === "=") setZoom(state.modal.zoom + 0.2);
          if (e.key === "-") setZoom(state.modal.zoom - 0.2);
        });
      }

      function bootstrap() {
        if (!(window.File && window.FileList && window.FileReader)) {
          setStatus("File API not supported.");
        }

        applyTheme();
        applyLang();
        updateCategories();
        filterItems();
        bindEvents();
      }

      bootstrap();
    })();
  </script>
</body>
</html>




